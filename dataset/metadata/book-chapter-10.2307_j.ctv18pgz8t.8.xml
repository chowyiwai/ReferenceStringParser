

<book xmlns:mml="http://www.w3.org/1998/Math/MathML"
      xmlns:oasis="http://docs.oasis-open.org/ns/oasis-exchange/table"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      dtd-version="0.2"
      xml:lang="fre">
   <collection-meta>
      <collection-id collection-id-type="jstor">books</collection-id>
   </collection-meta>
   <book-meta>
      <book-id book-id-type="doi">10.2307/j.ctv18pgz8t</book-id>
      <subj-group subj-group-type="discipline">
         <subject>Computer Science</subject>
      </subj-group>
      <book-title-group>
         <book-title>Éléments de programmation structurée</book-title>
      </book-title-group>
      <contrib-group>
         <contrib contrib-type="author" id="contrib1">
            <name name-style="western">
               <surname>MATTE</surname>
               <given-names>JEAN</given-names>
            </name>
         </contrib>
         <contrib contrib-type="author" id="contrib2">
            <name name-style="western">
               <surname>VILLARDIER</surname>
               <given-names>LOUIS</given-names>
            </name>
         </contrib>
      </contrib-group>
      <pub-date>
         <day>22</day>
         <month>04</month>
         <year>2011</year>
      </pub-date>
      <isbn content-type="ppub">9782760503472</isbn>
      <isbn content-type="epub">9782760521469</isbn>
      <publisher>
         <publisher-name>Presses de l'Université du Québec</publisher-name>
         <publisher-loc>Sainte-Foy, QC</publisher-loc>
      </publisher>
      <edition>1</edition>
      <permissions>
         <copyright-year>1984</copyright-year>
         <copyright-holder>Presses de l’Université du Québec</copyright-holder>
      </permissions>
      <self-uri xlink:href="https://www.jstor.org/stable/j.ctv18pgz8t"/>
      <abstract abstract-type="short">
         <p>Ce volume présente les concepts de base de la programmation fondée sur une approche structurée. Conçu pour un apprentissage individuel, il permet au lecteur de s’initier de façon graduelle aux étapes de la programmation. Chaque chapitre couvre un des aspects du processus de programmation et est abondamment illustré d’exemples.</p>
      </abstract>
      <counts>
         <page-count count="146"/>
      </counts>
      <custom-meta-group>
         <custom-meta>
            <meta-name>
                    lang
                </meta-name>
            <meta-value>fre</meta-value>
         </custom-meta>
      </custom-meta-group>
   </book-meta>
   <body>
      <book-part book-part-type="book-toc-page-order" indexed="yes">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctv18pgz8t.1</book-part-id>
                  <title-group>
                     <title>Front Matter</title>
                  </title-group>
                  <fpage>1</fpage>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctv18pgz8t.2</book-part-id>
                  <title-group>
                     <title>AVANT-PROPOS</title>
                  </title-group>
                  <contrib-group>
                     <contrib contrib-type="author" id="contrib1" xlink:type="simple">
                        <name name-style="western">
                           <surname>Louis</surname>
                           <given-names>Jean Matte</given-names>
                        </name>
                     </contrib>
                  </contrib-group>
                  <fpage>9</fpage>
                  <abstract>
                     <p>Ce volume est destiné à tous ceux qui veulent acquérir de solides connaissances en programmation par la présentation de l’étude des concepts clés de cette science. Il vise à outiller le lecteur de façon qu’il puisse écrire de bons programmes selon les règles de l’art. Basé sur l’approche structurée en programmation, il met l’accent là où il le faut, c’est-à-dire, sur le processus de programmation luimême plutôt que sur l’étape de la codification.</p>
                     <p>La <italic>programmation structurée</italic> est une carte maîtresse en programmation. Elle se fonde sur l’utilisation de techniques éprouvées en résolution de problème et sur la connaissance des principales</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctv18pgz8t.3</book-part-id>
                  <title-group>
                     <title>Table of Contents</title>
                  </title-group>
                  <fpage>11</fpage>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctv18pgz8t.4</book-part-id>
                  <title-group>
                     <title>INTRODUCTION</title>
                  </title-group>
                  <fpage>13</fpage>
                  <abstract>
                     <p>Programmer fut quelquefois considéré plus comme un art que comme une science. Cette approche, totalement empirique, se révéla souvent peu efficace et dispendieuse, les erreurs de programmation étant particulièrement coûteuses. C’est pourquoi au milieu des années 60 plusieurs personnes dont Edsger W. Dijkstra¹ ont travaillé à répandre le concept de la <italic>programmation structurée</italic>. Beaucoup d’articles ont été rédigés sur le sujet. Controversé à l’époque, ce concept tend aujourd’hui à se généraliser de plus en plus comme technique de programmation dans le milieu informatique.</p>
                     <p>L’idée de base est relativement simple. Il s’agit de découper un problème en sous-problèmes plus simples à</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctv18pgz8t.5</book-part-id>
                  <title-group>
                     <label>1</label>
                     <title>LES ETAPES D’UN PROJET DE PROGRAMMATION</title>
                  </title-group>
                  <fpage>15</fpage>
                  <abstract>
                     <p>Weinberg a écrit « La programmation est, au mieux, une communication entre deux espèces différentes »¹. Nous parlons naturellement de l’homme et de l’ordinateur. Ainsi, programmer c’est communiquer l’information nécessaire à une machine de façon qu’elle puisse accomplir ce que l’on attend d’elle. Cette information se présente sous la forme d’un ensemble de règles et d’opérations qui conduisent à la résolution du problème. Cette suite de règles et d’opérations constitue l’algorithme de la résolution du problème. L’algorithme est ensuite traduit dans un langage de programmation (par exemple, le BASIC) et constitue alors le programme. Résoudre un problème revient donc à</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctv18pgz8t.6</book-part-id>
                  <title-group>
                     <label>2</label>
                     <title>LE STRUCTUROGRAMME</title>
                  </title-group>
                  <fpage>19</fpage>
                  <abstract>
                     <p>L’idée de vouloir représenter de façon schématique et simplifiée une fonction ou une tâche ne date pas d’aujourd’hui. Ainsi, sommes-nous déjà familiarisés avec ce genre de diagramme, plus précisément appelé <italic>organigramme</italic>, qui illustre la hiérarchie des fonctions à l’intérieur d’un organisme et situe les personnes sur le plan des responsabilités au sein de ce même organisme. À titre d’exemple examinons l’organigramme d’une société.</p>
                     <p>L’intérêt de ce type de schéma n’est pas uniquement visuel, mais
avant tout de situer précisément chaque fonction et chaque personne à l’intérieur d’une structure hiérarchique qui présente l’organisation interne et les lignes d’autorité d’un organisme.</p>
                     <p>À chaque</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctv18pgz8t.7</book-part-id>
                  <title-group>
                     <label>3</label>
                     <title>LES STRUCTURES DE BASE</title>
                  </title-group>
                  <fpage>29</fpage>
                  <abstract>
                     <p>Le <italic>langage algorithmique</italic> est un outil proche du langage naturel, et qui, par sa structure syntaxique s’apparente à la façon dont s’expriment les individus. Au moyen de <italic>structures élémentaires</italic> que nous approfondirons dans ce chapitre, il permet de décrire de façon compréhensible pour les non-initiés des algorithmes qui pourront être par la suite codifiés dans un langage de programmation. Un algorithme se définit comme <italic>une séquence d’actions élémentaires réalisable à l’intérieur d’étapes limitées et produisant un résultat</italic>. Le langage algorithmique est un outil d’analyse précieux avec lequel vous devez vous familiariser. Son principal avantage est d’être indépendant du langage de</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctv18pgz8t.8</book-part-id>
                  <title-group>
                     <label>4</label>
                     <title>LA CODIFICATION</title>
                  </title-group>
                  <fpage>57</fpage>
                  <abstract>
                     <p>Les chapitres précédents ont présenté la façon de bâtir un structurogramme afin de représenter la structure générale d’un problème. fis ont aussi, à l’aide du langage algorithmique, expliqué comment décrire les algorithmes associés à chaque module du structurogramme. Pour compléter le processus de programmation, il reste à réaliser l’étape de la <italic>codification</italic>. Cette étape qui consiste à traduire les énoncés algorithmiques en langage de programmation constitue l’étape opérationnelle du processus. Elle se fait en convertissant les énoncés algorithmiques en instructions exécutables par un ordinateur.</p>
                     <p>Cette approche modulaire permet une <italic>programmation ascendante</italic>. Cela veut dire que l’on commence par écrire les</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctv18pgz8t.9</book-part-id>
                  <title-group>
                     <label>5</label>
                     <title>LA MISE AU POINT</title>
                  </title-group>
                  <fpage>65</fpage>
                  <abstract>
                     <p>Rédiger un programme selon les règles du langage est une chose et faire produire les résultats escomptés en est une autre. Cette étape est parfois longue, surtout si nous n’avons pas accordé suffisamment d’attention aux étapes d’élaboration de la logique et du langage algorithmique. Il s’agit, à l’étape de la <italic>mise au point</italic>, de vérifier si notre programme produit les résultats attendus selon certaines conditions choisies et s’il produira de bons résultats dans toutes les autres conditions qui pourront se présenter. Pour ce faire, il faut élaborer un <italic>plan de test</italic> afin de vérifier le bon fonctionnement de notre programme</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctv18pgz8t.10</book-part-id>
                  <title-group>
                     <label>6</label>
                     <title>LA DOCUMENTATION</title>
                  </title-group>
                  <fpage>75</fpage>
                  <abstract>
                     <p>La documentation d’un projet informatique est l’étape finale du processus de programmation. Cette étape, très souvent négligée par les programmeurs, permet à d’autres personnes de pouvoir ultérieurement suivre le raisonnement logique d’un programme et éventuellement lui apporter des modifications ou des ajouts. L’un des objectifs de la <italic>programmation structurée</italic> est justement de permettre une mise à jour plus facile d’un programme. À cet effet, on peut incorporer, dans le listage du programme, un certain nombre de commentaires donnant une explication sur chacun des sous-programmes.</p>
                     <p>Tout dépendant à qui l’on s’adresse, il est souhaitable de distinguer deux types de documentation. D’une</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctv18pgz8t.11</book-part-id>
                  <title-group>
                     <label>7</label>
                     <title>LA RÉSOLUTION D’UN PROBLÈME:</title>
                     <subtitle>RECHERCHE D’UNE STRATÉGIE</subtitle>
                  </title-group>
                  <fpage>79</fpage>
                  <abstract>
                     <p>Nous avons abordé diverses techniques permettant de structurer un projet afin de le programmer. Dans un premier exemple, nous ne présentons pas un projet à proprement parler. Il s’agit plutôt d’un module pouvant être utilisé dans un projet plus vaste. Nous insistons surtout sur la démarche qui permet de résoudre le problème ; celle-ci utilise largement le langage algorithmique. Elle accentue l’importance de diviser le problème principal en problèmes plus simples et de les analyser jusqu’à ce qu’on puisse en faire la programmation. C’est souvent à partir de problèmes plus simples que naissent les idées qui permettent de résoudre le</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctv18pgz8t.12</book-part-id>
                  <title-group>
                     <label>8</label>
                     <title>LA GÉNÉRALISATION DE LA DÉMARCHE:</title>
                     <subtitle>UTILISATION D’UN PROBLÈME ANALOGUE</subtitle>
                  </title-group>
                  <fpage>95</fpage>
                  <abstract>
                     <p>En programmation, on doit se fier beaucoup à son expérience pour résoudre un problème. En outre, la plupart des problèmes traités présentent souvent des différences entre eux. Certains ont cependant des structures analogues qui appellent des solutions voisines. Il ne s’agit pas de copier une solution déjà faite, mais plutôt de s’inspirer des stratégies qui ont conduit à résoudre un problème et à découvrir une solution originale.</p>
                     <p>Ce deuxième exemple vise justement à mettre à profit cette idée de problème analogue dans la recherche d’une solution. Il est pourtant différent du premier exemple à plus d’un égard, et la solution</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctv18pgz8t.13</book-part-id>
                  <title-group>
                     <label>9</label>
                     <title>QUELQUES CONTRAINTES LIÉES AUX VERSIONS BASIC</title>
                  </title-group>
                  <fpage>111</fpage>
                  <abstract>
                     <p>Les techniques de programmation et de documentation déjà exposées dans ce volume constituent de bonnes habitudes pour une programmation selon des règles utilisées par les gens de métier. Cependant, BASIC n’est pas le langage le mieux adapté à la <italic>programmation structurée</italic>.</p>
                     <p>Plusieurs versions BASIC ne possèdent pas les instructions correspondant aux structures de base étudiées précédemment : <italic>SINON (ELSE)</italic> de la structure alternative et <italic>RÉPÉTER TANT QUE (WHILE)</italic> de la structure répétitive. Nous vous présentons dans les sections qui suivent la façon de contourner ces difficultés en simulant ces deux instructions BASIC. De cette façon, on évite l’emploi abusif de</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctv18pgz8t.14</book-part-id>
                  <title-group>
                     <label>10</label>
                     <title>LES OUTILS D’AIDE À LA PROGRAMMATION</title>
                  </title-group>
                  <fpage>121</fpage>
                  <abstract>
                     <p>Dans ce chapitre, nous allons vous présenter sept formulaires qui serviront d’outils d’aide à la programmation et que nous vous invitons à utiliser dans le cadre de vos projets de programmation. Ces formulaires sont identifiés en fonction de leur rôle respectif.</p>
                     <p>La grille imprimante</p>
                     <p>L’image-écran</p>
                     <p>La description d’écran</p>
                     <p>La description de fichier</p>
                     <p>Le langage algorithmique</p>
                     <p>Le plan de test</p>
                     <p>Les sorties anticipées</p>
                     <p>Les formulaires servent à documenter le programme. En soit, ils constituent une partie importante de la documentation technique.</p>
                     <p>Voici la description des éléments figurant sur chaque formulaire ainsi qu’un exemple d’utilisation de ces derniers.</p>
                     <p>Cette grille est utilisée</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctv18pgz8t.15</book-part-id>
                  <title-group>
                     <title>INDEX</title>
                  </title-group>
                  <fpage>139</fpage>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctv18pgz8t.16</book-part-id>
                  <title-group>
                     <title>Back Matter</title>
                  </title-group>
                  <fpage>144</fpage>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
   </body>
</book>
