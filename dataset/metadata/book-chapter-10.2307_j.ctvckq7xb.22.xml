

<book xmlns:oasis="http://docs.oasis-open.org/ns/oasis-exchange/table"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:mml="http://www.w3.org/1998/Math/MathML"
      dtd-version="0.2"
      xml:lang="eng">
   <collection-meta>
      <collection-id collection-id-type="jstor">books</collection-id>
   </collection-meta>
   <book-meta>
      <book-id book-id-type="doi">10.2307/j.ctvckq7xb</book-id>
      <subj-group subj-group-type="discipline">
         <subject>Mathematics</subject>
         <subject>Technology</subject>
         <subject>Computer Science</subject>
      </subj-group>
      <book-title-group>
         <book-title>Mathematics and Computation</book-title>
         <subtitle>A Theory Revolutionizing Technology and Science</subtitle>
      </book-title-group>
      <contrib-group>
         <contrib contrib-type="author" id="contrib1">
            <name name-style="western">
               <surname>Wigderson</surname>
               <given-names>Avi</given-names>
            </name>
         </contrib>
      </contrib-group>
      <pub-date>
         <day>29</day>
         <month>10</month>
         <year>2019</year>
      </pub-date>
      <isbn content-type="ppub">9780691189130</isbn>
      <isbn content-type="epub">9780691192543</isbn>
      <isbn content-type="epub">0691192545</isbn>
      <publisher>
         <publisher-name>Princeton University Press</publisher-name>
         <publisher-loc>Princeton; Oxford</publisher-loc>
      </publisher>
      <permissions>
         <copyright-year>2019</copyright-year>
         <copyright-holder>Avi Wigderson</copyright-holder>
      </permissions>
      <self-uri xlink:href="https://www.jstor.org/stable/j.ctvckq7xb"/>
      <abstract abstract-type="short">
         <p> &lt;p&gt;<bold>An introduction to computational complexity theory, its connections and interactions with mathematics, and its central role in the natural and social sciences, technology, and philosophy</bold>  &lt;p&gt;<italic>Mathematics and Computation</italic> provides a broad, conceptual overview of computational complexity theory-the mathematical study of efficient computation. With important practical applications to computer science and industry, computational complexity theory has evolved into a highly interdisciplinary field, with strong links to most mathematical areas and to a growing number of scientific endeavors.  &lt;p&gt;Avi Wigderson takes a sweeping survey of complexity theory, emphasizing the field's insights and challenges. He explains the ideas and motivations leading to key models, notions, and results. In particular, he looks at algorithms and complexity, computations and proofs, randomness and interaction, quantum and arithmetic computation, and cryptography and learning, all as parts of a cohesive whole with numerous cross-influences. Wigderson illustrates the immense breadth of the field, its beauty and richness, and its diverse and growing interactions with other areas of mathematics. He ends with a comprehensive look at the theory of computation, its methodology and aspirations, and the unique and fundamental ways in which it has shaped and will further shape science, technology, and society. For further reading, an extensive bibliography is provided for all topics covered.  &lt;p&gt;<italic>Mathematics and Computation</italic> is useful for undergraduate and graduate students in mathematics, computer science, and related fields, as well as researchers and teachers in these fields. Many parts require little background, and serve as an invitation to newcomers seeking an introduction to the theory of computation.    &lt;ul&gt; &lt;li&gt;Comprehensive coverage of computational complexity theory, and beyond    &lt;li&gt;High-level, intuitive exposition, which brings conceptual clarity to this central and dynamic scientific discipline   &lt;li&gt;Historical accounts of the evolution and motivations of central concepts and models   &lt;li&gt;A broad view of the theory of computation's influence on science, technology, and society   &lt;li&gt;Extensive bibliography        </p>
      </abstract>
      <custom-meta-group>
         <custom-meta>
            <meta-name>
                    lang
                </meta-name>
            <meta-value>eng</meta-value>
         </custom-meta>
      </custom-meta-group>
   </book-meta>
   <body>
      <book-part book-part-type="book-toc-page-order" indexed="yes">
         <body>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.1</book-part-id>
                  <title-group>
                     <title>Front Matter</title>
                  </title-group>
                  <fpage>i</fpage>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.2</book-part-id>
                  <title-group>
                     <title>Table of Contents</title>
                  </title-group>
                  <fpage>vii</fpage>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.3</book-part-id>
                  <title-group>
                     <title>Acknowledgments</title>
                  </title-group>
                  <fpage>xiii</fpage>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.4</book-part-id>
                  <title-group>
                     <label>1</label>
                     <title>Introduction</title>
                  </title-group>
                  <fpage>1</fpage>
                  <abstract>
                     <p>Here is just one tip of the iceberg we‚Äôll explore in this book: How much time does it take to find the prime factors of a 1,000-digit integer? The facts are that (1) we can‚Äôt even roughly estimate the answer: it could be less than a second or more than a million years, and (2) practically all electronic commerce and Internet security systems in existence today rest on the belief that it takes more than a million years!</p>
                     <p>Digesting even this single example begins to illuminate the conceptual revolution of <italic>computational complexity theory</italic>, to which this book is devoted. It</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.5</book-part-id>
                  <title-group>
                     <label>2</label>
                     <title>Prelude:</title>
                     <subtitle>Computation, undecidability, and limits to mathematical knowledge</subtitle>
                  </title-group>
                  <fpage>14</fpage>
                  <abstract>
                     <p>This short section will briefly recount the history of ideas leading the the birth of computational complexity theory.</p>
                     <p>Mathematical classification problems Which mathematical structures can we hope to understand? Consider any particular class of mathematical objects and any particular relevant property. We seek to <italic>understand</italic> which of the objects have the property and which do not. Examples of this very general <italic>classification problem</italic> include the following¬π:</p>
                     <p>1. Which Diophantine equations have solutions?</p>
                     <p>2. Which knots are unknotted? (see Figure 1)</p>
                     <p>3. Which planar maps are 4-colorable? (see Figure 2)</p>
                     <p>4. Which theorems are provable in Peano arithmetic?</p>
                     <p>5. Which pairs of smooth manifolds are diffeomorphic?</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.6</book-part-id>
                  <title-group>
                     <label>3</label>
                     <title>Computational complexity 101:</title>
                     <subtitle>The basics, ùí´, and ùí©ùí´</subtitle>
                  </title-group>
                  <fpage>19</fpage>
                  <abstract>
                     <p>In this chapter, we develop the basic notions of computational problems; data representation; efficient computations; efficient reductions between problems; efficient verification of proofs; the classes ùí´, ùí©ùí´, and coùí©ùí´; and the notion of ùí©ùí´-complete problems. We focus on <italic>classification</italic> (or decision) problems; other types of problems, and classes, (enumeration, approximation, construction, etc.) are studied as well, and some will be discussed later in the book.</p>
                     <p>When studying efficiency, we will focus on <italic>time</italic> as the primary resource of algorithms. By ‚Äútime‚Äù, I mean the number of elementary operations¬π performed. Other resources of algorithms, such as memory, parallelism, communication, and randomness,</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.7</book-part-id>
                  <title-group>
                     <label>4</label>
                     <title>Problems and classes inside (and around) ùí©ùí´</title>
                  </title-group>
                  <fpage>47</fpage>
                  <abstract>
                     <p>This chapter touches on different aspects and variants of the ùí´ vs. ùí©ùí´ question studied in computational complexity, the resulting complexity classes in the neighborhood of these two main classes, and the central questions about them. The first brief section lists a few types of problems that are not classification problems, leading mostly to classes containing ùí©ùí´. The remaining sections are devoted to problems and classes in the potentially vast universe between the easiest and hardest problems in ùí©ùí´, namely, between ùí´ and ùí©ùí´-complete. We discuss degrees of intermediate complexities of problems in this universe, as well as <italic>constraint satisfaction</italic>
                     </p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.8</book-part-id>
                  <title-group>
                     <label>5</label>
                     <title>Lower bounds, Boolean circuits, and attacks on ùí´ vs. ùí©ùí´</title>
                  </title-group>
                  <fpage>61</fpage>
                  <abstract>
                     <p>To prove that ùí´ ‚â† ùí©ùí´, we must show that for a given problem, no efficient algorithm exists. A result of this type is called a <italic>lower bound</italic> (limiting from below the computational complexity of the problem). Several powerful techniques for proving lower bounds have emerged in the past decades. They apply in two (very different) settings. I now describe both and explain why they seem to stop short of proving ùí´ ‚â† ùí©ùí´. I only mention very briefly the first, diagonalization, and concentrate on the second, Boolean circuits.</p>
                     <p>Note that Boolean circuits are studied as a computational model in</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.9</book-part-id>
                  <title-group>
                     <label>6</label>
                     <title>Proof complexity</title>
                  </title-group>
                  <fpage>73</fpage>
                  <abstract>
                     <p>The reader will have seen, depending on experience, a variety of mathematical theorems and their proofs in various mathematical areas. However, it is quite likely that the focus this chapter takes on proofs, as well as the types of theorems considered here, are quite different than what you are used to. This fresh view of proofs is incredibly rich and brings out a beautiful set of mathematical problems and results. For extensive surveys on this material, see [BP98, Seg07, RW00], and in a bigger context, the books by Kraj√≠ƒçek [Kra95, Kra19].</p>
                     <p>The concept of <italic>proof</italic> is what distinguishes the study</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.10</book-part-id>
                  <title-group>
                     <label>7</label>
                     <title>Randomness in computation</title>
                  </title-group>
                  <fpage>89</fpage>
                  <abstract>
                     <p>The marriage of randomness and computation has been one of the most fertile ideas in computer science, with a wide variety of models ranging from cryptography to computational learning theory to distributed computing. It enabled new understanding of fundamental concepts, such as knowledge, secrecy, learning, proof, and indeed, randomness itself. In this and the next chapter, we shall just touch the tip of the iceberg‚Äîthings most closely related to the questions of efficient computation and proofs. Sections 7.1 and 7.2 tell the (seemingly) contradictory stories of the power and weakness of algorithmic randomness. Section 7.3 explains the notion of</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.11</book-part-id>
                  <title-group>
                     <label>8</label>
                     <title>Abstract pseudo-randomness</title>
                  </title-group>
                  <fpage>105</fpage>
                  <abstract>
                     <p>In the previous chapter, we saw how the notion of <italic>computational pseudo-randomness</italic> was essential for understanding the power of probabilistic algorithms. Indeed, this notion and its variations, as well as the more general notion of <italic>computational indistinguishability</italic>, have had a huge impact on many aspects of computational complexity, including circuit complexity, computational learning theory, and of course cryptography, where it underlies most definitions and results.</p>
                     <p>Now let us extend this notion considerably; indeed, take it to its logical conclusion. Rather than consider indistinguishability of distributions from a family of <italic>computationally bounded</italic> observers, we‚Äôll simply allow arbitrary families of observers. We</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.12</book-part-id>
                  <title-group>
                     <label>9</label>
                     <title>Weak random sources and randomness extractors</title>
                  </title-group>
                  <fpage>124</fpage>
                  <abstract>
                     <p>Probabilistic algorithms and many other applications of randomness are analyzed assuming access to an unlimited supply of <italic>independent, unbiased</italic> bits. Does reality provide such perfect randomness? Suppose nature is deterministic, and perfect randomness is simply nonexistent. Even then, Section 7.2 demonstrates that believable <italic>hardness assumptions</italic> imply ùìëùí´ùí´ = ùí´ (namely, every probabilistic algorithm can be efficiently de-randomized), and so all these algorithmic applications of perfect randomness survive in a deterministic world. But suppose that we want <italic>unconditional</italic> results. What are the minimal assumptions about nature that will afford the same algorithmic applications?</p>
                     <p>A reasonable middle ground regarding nature, which seems</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.13</book-part-id>
                  <title-group>
                     <label>10</label>
                     <title>Randomness and interaction in proofs</title>
                  </title-group>
                  <fpage>132</fpage>
                  <abstract>
                     <p>The introduction of randomness, and interaction, into <italic>proofs</italic> (and proof systems), completely rejuvenated this central tenet of mathematics. It had a remarkable impact on theoretical computer science and many related areas, with quite a number of unexpected consequences. In particular, it resulted in new, powerful characterizations of ùí©ùí´ and other complexity classes.</p>
                     <p>In this chapter, we survey the main definitions and results on probabilistic and interactive proofs, and their meaning and impact. The monograph [Gol99] offers much more detail and precision; a comprehensive survey of how this field evolved in the past 2 decades would be welcome! We note that</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.14</book-part-id>
                  <title-group>
                     <label>11</label>
                     <title>Quantum computing</title>
                  </title-group>
                  <fpage>146</fpage>
                  <abstract>
                     <p>This chapter describes a unique and exciting interaction between computational complexity and physics that probes the nature of reality and brings a new perspective to its study. We will discuss some of the many facets of this interaction. There are many excellent texts on this broad subject, including [KSV02, NC10, Aar13a], each with a different perspective and style.</p>
                     <p>Let us return to the most basic question: What are the problems that can be solved efficiently? In the beginning of this book, we defined them to be in the class ùí´, those problems solvable in <italic>deterministic</italic> polynomial time. Rapid progress in</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.15</book-part-id>
                  <title-group>
                     <label>12</label>
                     <title>Arithmetic complexity</title>
                  </title-group>
                  <fpage>160</fpage>
                  <abstract>
                     <p>We now leave the Boolean domain and discuss instead the computation of <italic>polynomials</italic> over arbitrary fields. Polynomials, being so basic and so useful, are studied in a variety of mathematical areas. Here we study their complexity: How many arithmetic operations are required to compute natural ones (e.g., the elementary symmetric polynomials, determinant, permanent, matrix multiplication, convolution)? This study is clearly natural from mathematical and practical standpoints. But once the computational complexity machinery of reductions and completeness is applied, it leads to analogs of ùí´ vs. ùí©ùí´ and other complexity questions that seem easier to solve here than in the Boolean</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.16</book-part-id>
                  <title-group>
                     <label>13</label>
                     <title>Interlude:</title>
                     <subtitle>Concrete interactions between math and computational complexity</subtitle>
                  </title-group>
                  <fpage>174</fpage>
                  <abstract>
                     <p>The introduction discussed the variety of interactions between math and computation at a high level. In this chapter we will meet concrete examples of interactions of computational complexity theory with different fields of mathematics. I aim for variety‚Äîthis section demonstrates that hardly any area of modern mathematics is untouched by this computational connection, which in some cases is quite surprising.</p>
                     <p>I have chosen to focus on essentially one problem or development in each mathematical field. Typically, this touches only a small subarea, which does not do justice to a wealth of connections. Thus, each section should be viewed as</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.17</book-part-id>
                  <title-group>
                     <label>14</label>
                     <title>Space complexity:</title>
                     <subtitle>Modeling limited memory</subtitle>
                  </title-group>
                  <fpage>198</fpage>
                  <abstract>
                     <p>Despite remarkable technological advances in miniaturizing computer memory (we are accustomed to carrying gigabytes of movies, pictures, and music in our pockets), space is a costly resource whose minimization is of importance in numerous applications, especially those dealing with ‚Äúbig data.‚Äù One important message of this short chapter is that surprising things can be done with very little memory.</p>
                     <p>We start by describing the basic computational model of space-bounded algorithms, the main complexity classes studied, and some of the most basic results and open problems from the classical theory of space complexity. Then, to demonstrate the power of small space</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.18</book-part-id>
                  <title-group>
                     <label>15</label>
                     <title>Communication complexity:</title>
                     <subtitle>Modeling information bottlenecks</subtitle>
                  </title-group>
                  <fpage>207</fpage>
                  <abstract>
                     <p>This field of communication complexity studies the communication costs of computing <italic>discrete</italic> functions whose input is split between two parties. It was born in 1979 with a paper by Yao [Yao79], following similar work of Abelson on <italic>continuous</italic> functions. The field grew rapidly, both mathematically and applications-wise, and the comprehensive book of Kushilevitz and Nisan [KN97] covers the first two decades of activity. Today, two decades after that book was published, there is a dire need for a new book summarizing the amazing work that has been done since, with some very recent breakthroughs, including solutions to very old problems</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.19</book-part-id>
                  <title-group>
                     <label>16</label>
                     <title>On-line algorithms:</title>
                     <subtitle>Coping with an unknown future</subtitle>
                  </title-group>
                  <fpage>230</fpage>
                  <abstract>
                     <p>Is hindsight really 20/20, as the saying goes? What exactly is the power of clairvoyance? Here are a few concrete examples from people‚Äôs lives, encompassing the need to make periodic decisions without knowing the future. They illustrate the need for the models, algorithms, and analysis we discuss in this chapter.</p>
                     <p>Investment: You own some portfolio of stocks. Every day (or month, or year), given the prices of the stocks, you make a decision to buy and sell some. How should you choose?</p>
                     <p>Gym: You go on a whim every so often to the gym (or the theater). When you go</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.20</book-part-id>
                  <title-group>
                     <label>17</label>
                     <title>Computational learning theory, AI, and beyond</title>
                  </title-group>
                  <fpage>238</fpage>
                  <abstract>
                     <p>In this chapter, we face an extremely general modeling problem: how to define, and then design, algorithms that learn from experience and use it to cope with new, different situations that may arise. In this generality, such algorithms must be able to learn to walk and talk like a child, to fly or swim, find food and shelter like a young animal, make up theories from data like a scientist, prove theorems like a mathematician, play musical instruments and compose, lead an army or start up a company, discuss philosophy and emotions, laugh at jokes, have offspring, and so forth.</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.21</book-part-id>
                  <title-group>
                     <label>18</label>
                     <title>Cryptography:</title>
                     <subtitle>Modeling secrets and lies, knowledge and trust</subtitle>
                  </title-group>
                  <fpage>260</fpage>
                  <abstract>
                     <p>Cryptography is a truly vast field. It serves as a foundation for its more practical sibling of computer security, which employs numerous computer professionals around the globe and is a major part of the computer industry. Cryptography is also directly connected to the very related but distinct field of digital privacy, always in the news for obvious societal concerns, and for which a beautiful new theoretical framework has recently been developed (see, e.g., the surveys [DR14, Vad17]). A comprehensive text on the modern foundations of cryptography is Goldreich‚Äôs two volumes [Gol04].</p>
                     <p>We have discussed aspects of cryptography a few times</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.22</book-part-id>
                  <title-group>
                     <label>19</label>
                     <title>Distributed computing:</title>
                     <subtitle>Coping with asynchrony</subtitle>
                  </title-group>
                  <fpage>281</fpage>
                  <abstract>
                     <p>Distributed computing captures any situation in which many computers or processes aim to achieve certain goals (common or separate) in a way that necessitates interaction. This of course includes server farms; supercomputers; sensor networks; organizational intranets; and the Internet; but also your single laptop, in which many components have some independence. Moreover, it can serve as a model for numerous phenomena in the natural sciences. Clearly, this is a vast and heterogeneous field.</p>
                     <p>Distributed computing is similar to cryptography in many ways, including the interactions of many parties, the heterogeneity and multitudes of objectives, and the complexity of formal modeling,</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.23</book-part-id>
                  <title-group>
                     <label>20</label>
                     <title>Epilogue:</title>
                     <subtitle>A broader perspective of ToC</subtitle>
                  </title-group>
                  <fpage>299</fpage>
                  <abstract>
                     <p>This book has focused mostly on computational complexity, both as a major mathematical area, describing its rich internal structure and its broad reaches into other areas of mathematics, and as a central, pivotal area of the theory of computation (ToC). This chapter is devoted to a panoramic view of ToC that extends far beyond the intersection of math and computer science. The great impact of technology on society tends to obscure the intellectual foundations that ToC rests on from laypersons, but sometimes from experts as well. Even to many who know and understand them, these theoretical ideas are often viewed</p>
                  </abstract>
               </book-part-meta>
            </book-part>
            <book-part>
               <book-part-meta>
                  <book-part-id book-part-id-type="jstor">j.ctvckq7xb.24</book-part-id>
                  <title-group>
                     <title>References</title>
                  </title-group>
                  <fpage>349</fpage>
               </book-part-meta>
            </book-part>
         </body>
      </book-part>
   </body>
</book>
